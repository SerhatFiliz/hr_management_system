from django.db import models
from django.contrib.auth.models import User # Required for User relationship (Employee)
from accounts.models import Company # Required for Company relationships (Employee, JobPosting, Candidate)
from django.core.validators import FileExtensionValidator, EmailValidator # Required for validation (Candidate)


class Employee(models.Model):
    """
    It links an internal User (login capability) to a specific Company.

    Fields:
    - id (PK): Automatically generated by Django.
    - user (FK): One-to-One relationship with Django's built-in User model.
    - company (FK): Many-to-One relationship with the Company model.
    - created_at: Timestamp for creation, automatically set.
    """
    user = models.OneToOneField(
        User,
        on_delete=models.CASCADE, # If the User account is deleted, the Employee profile is also deleted.
        help_text="The associated user account for this HR employee."
    )
    company = models.ForeignKey(
        Company,
        on_delete=models.CASCADE, # If the Company is deleted, its associated HR Employees are also deleted.
        related_name='hr_employees', # Allows accessing Employee objects from a Company instance (e.g., my_company.hr_employees.all()). if we don't use this -> my_company.employee_set.all()
        db_index=True, # db_index added for performance
        help_text="The company this HR employee is associated with."
    )
    created_at = models.DateTimeField(auto_now_add=True, help_text="The date and time when the employee record was created.")

    class Meta:
        verbose_name = "HR Employee"
        verbose_name_plural = "HR Employees"
        ordering = ['user__last_name', 'user__first_name'] # Orders by the related User's last then first name

    def __str__(self):

        return f"{self.user.first_name} {self.user.last_name} ({self.company.name})"


class JobPosting(models.Model):
    """
    Represents a job vacancy posted by a company.

    Fields:
    - id (PK): Automatically generated by Django.
    - company (FK): Many-to-One relationship with the Company model.
    - title: Title of the job posting.
    - description: Detailed description of the job.
    - created_by (FK): Many-to-One relationship with the Employee model.
    - created_at: Timestamp for creation, automatically set.
    - updated_at: Timestamp for last update, automatically updated.
    - is_active: Status of the job posting (active/inactive).
    - auto_title_generated: Boolean to track if title was AI-generated.

    Relationships:
    - Many-to-One with Company: Each JobPosting belongs to one Company.
    - Many-to-One with Employee (via created_by): Each JobPosting is created by one Employee.
    - Many-to-Many via Application: A JobPosting can have MANY Applications (from Candidates).
    """
    company = models.ForeignKey(
        Company,
        on_delete=models.CASCADE, # If the Company is deleted, its job postings are also deleted.
        related_name='job_postings', # Allows accessing JobPosting objects from a Company instance.
        db_index=True, # db_index added for performance
        help_text="The company that posted this job."
    )
    title = models.CharField(max_length=255, help_text="Title of the job posting.")
    description = models.TextField(help_text="Detailed description of the job.")
    created_by = models.ForeignKey(
        Employee, # As per ER Diagram, created by an Employee (HR Staff), not just any User.
        on_delete=models.SET_NULL, # If the creating Employee is deleted, this field becomes NULL.
        null=True, blank=True, # Allows the field to be optional (e.g., if creator is deleted).
        related_name='created_job_postings', # Allows accessing JobPosting objects from an Employee instance.
        help_text="The HR Employee who created this job posting."
    )
    created_at = models.DateTimeField(auto_now_add=True, help_text="The date and time when the job posting was created.")
    updated_at = models.DateTimeField(auto_now=True, help_text="The date and time when the job posting was last updated.")
    is_active = models.BooleanField(default=True, db_index=True, help_text="Whether the job posting is currently active.") # db_index added for performance
    auto_title_generated = models.BooleanField(default=False, help_text="Was the title generated by AI?") # Added for AI integration tracking

    class Meta:
        verbose_name = "Job Posting"
        verbose_name_plural = "Job Postings"
        ordering = ['-created_at'] # Orders job postings by creation date, newest first

    def __str__(self):
        return f"{self.title} at {self.company.name}"


class Candidate(models.Model):
    """
    Represents a job candidate applying for positions.
    Candidate profiles are managed by HR employees.

    Fields:
    - id (PK): Automatically generated by Django.
    - company (FK): Many-to-One relationship with the Company model.
    - first_name: Candidate's first name.
    - last_name: Candidate's last name.
    - email: Unique email address for the candidate.
    - resume: File field for PDF resumes, with validation.
    - created_by (FK): Many-to-One relationship with the Employee model.
    - created_at: Timestamp for creation, automatically set.

    Relationships:
    - Many-to-One with Company: Each Candidate is associated with one Company.
    - Many-to-One with Employee (via created_by): Each Candidate record is created by one Employee.
    - Many-to-Many via Application: A Candidate can have MANY Applications (to JobPostings).
    """
    company = models.ForeignKey(
        Company,
        on_delete=models.CASCADE, # If the Company is deleted, its associated Candidate records are also deleted.
        related_name='candidates', # Allows accessing Candidate objects from a Company instance.
        db_index=True, # db_index added for performance
        help_text="The company this candidate is applying to or associated with."
    )
    first_name = models.CharField(max_length=100, help_text="Candidate's first name.")
    last_name = models.CharField(max_length=100, help_text="Candidate's last name.")
    email = models.EmailField(
        max_length=255,
        unique=True,
        db_index=True, # db_index added for performance
        validators=[EmailValidator()], # Explicit EmailValidator for clarity/consistency
        help_text="Candidate's unique email address."
    )
    resume = models.FileField(
        upload_to='resumes/',
        blank=True,
        null=True,
        validators=[FileExtensionValidator(allowed_extensions=['pdf'])], # Validator to ensure only PDF files are uploaded
        help_text="Candidate's resume file (PDF only)."
    )
    created_by = models.ForeignKey(
        Employee, # As per ER Diagram, created by an Employee (HR Staff).
        on_delete=models.SET_NULL,
        null=True, blank=True,
        related_name='created_candidates', # Allows accessing Candidate objects from an Employee instance.
        help_text="The HR Employee who created this candidate record."
    )
    created_at = models.DateTimeField(auto_now_add=True, help_text="The date and time when the candidate record was created.")

    class Meta:
        verbose_name = "Candidate"
        verbose_name_plural = "Candidates"
        ordering = ['last_name', 'first_name'] # Orders candidates by last then first name

    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.email})"


class Application(models.Model):
    """
    Represents an application of a candidate to a specific job posting.
    This acts as the intermediary table for the Many-to-Many relationship between JobPosting and Candidate,

    Fields:
    - id (PK): Automatically generated by Django.
    - candidate (FK): Many-to-One relationship with the Candidate model.
    - job_posting (FK): Many-to-One relationship with the JobPosting model.
    - application_date: Timestamp for application submission, automatically set.
    - status: Current status of the application (e.g., Pending, Reviewed).

    Relationships:
    - Many-to-One with Candidate: Each Application is from one Candidate.
    - Many-to-One with JobPosting: Each Application is for one JobPosting.
    - Implicit Many-to-Many between Candidate and JobPosting: Through this Application model.
    """
    candidate = models.ForeignKey(
        Candidate,
        on_delete=models.CASCADE, # If the Candidate is deleted, their applications are also deleted.
        related_name='applications', # Allows accessing Application objects from a Candidate instance.
        help_text="The candidate who submitted this application."
    )
    job_posting = models.ForeignKey(
        JobPosting,
        on_delete=models.CASCADE, # If the JobPosting is deleted, its associated applications are also deleted.
        related_name='applications', # Allows accessing Application objects for a JobPosting instance.
        help_text="The job posting this application is for."
    )
    application_date = models.DateTimeField(auto_now_add=True, help_text="The date and time when the application was submitted.")
    status = models.CharField(
        max_length=50,
        default='Pending',
        choices=[
            ('Pending', 'Pending'),
            ('Reviewed', 'Reviewed'),
            ('Interviewed', 'Interviewed'),
            ('Rejected', 'Rejected'),
            ('Hired', 'Hired'),
        ],
        db_index=True, # db_index added for performance
        help_text="Current status of the application (e.g., Pending, Reviewed, Interviewed, Rejected, Hired)."
    )

    class Meta:
        verbose_name = "Application"
        verbose_name_plural = "Applications"
        # Using UniqueConstraint, the modern approach for unique combinations
        constraints = [
            models.UniqueConstraint(fields=['candidate', 'job_posting'], name='unique_application_for_job')
        ]
        ordering = ['-application_date'] # Orders applications by date, newest first

    def __str__(self):
        return f"Application by {self.candidate.first_name} {self.candidate.last_name} for {self.job_posting.title}"